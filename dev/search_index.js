var documenterSearchIndex = {"docs":
[{"location":"api/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"api/#Integrals","page":"Public API","title":"Integrals","text":"","category":"section"},{"location":"api/#Specializations","page":"Public API","title":"Specializations","text":"","category":"section"},{"location":"api/#Aliases","page":"Public API","title":"Aliases","text":"","category":"section"},{"location":"api/#Integration-Rules","page":"Public API","title":"Integration Rules","text":"","category":"section"},{"location":"api/#Derivatives","page":"Public API","title":"Derivatives","text":"","category":"section"},{"location":"api/#MeshIntegrals.integral","page":"Public API","title":"MeshIntegrals.integral","text":"integral(f, geometry[, rule]; kwargs...)\n\nNumerically integrate a given function f(::Point) over the domain defined by a geometry using a particular numerical integration rule with floating point precision of type FP.\n\nArguments\n\nf: an integrand function, i.e. any callable with a method f(::Meshes.Point)\ngeometry: a Meshes.jl Geometry or Domain that defines the integration domain\nrule: optionally, the IntegrationRule used for integration (by default\n\nGaussKronrod() in 1D and HAdaptiveCubature() else)\n\nKeyword Arguments\n\ndiff_method::DifferentiationMethod: manually specifies the differentiation method use to\n\ncalculate Jacobians within the integration domain.\n\nFP = Float64: manually specifies the desired output floating point precision\n\n\n\n\n\n","category":"function"},{"location":"api/#MeshIntegrals.integral-Union{Tuple{T}, Tuple{DM}, Tuple{Any, Meshes.BezierCurve, IntegrationRule}} where {DM<:DifferentiationMethod, T<:AbstractFloat}","page":"Public API","title":"MeshIntegrals.integral","text":"integral(f, curve::BezierCurve[, rule = GaussKronrod()]; kwargs...)\n\nLike integral but integrates along the domain defined by curve.\n\nSpecial Keyword Arguments\n\nalg = Meshes.Horner():  the method to use for parametrizing curve. Alternatively,\n\nalg=Meshes.DeCasteljau() can be specified for increased accuracy, but comes with a steep performance cost, especially for curves with a large number of control points.\n\n\n\n\n\n","category":"method"},{"location":"api/#MeshIntegrals.integral-Union{Tuple{I}, Tuple{Any, Meshes.PolyArea, I}} where I<:IntegrationRule","page":"Public API","title":"MeshIntegrals.integral","text":"integral(f, area::PolyArea[, rule = HAdaptiveCubature()]; kwargs...)\n\nLike integral but integrates over the surface domain defined by a PolyArea. The surface is first discretized into facets that are integrated independently using the specified integration rule.\n\n\n\n\n\n","category":"method"},{"location":"api/#MeshIntegrals.integral-Union{Tuple{I}, Tuple{Any, Meshes.Ring, I}} where I<:IntegrationRule","page":"Public API","title":"MeshIntegrals.integral","text":"integral(f, ring::Ring[, rule = GaussKronrod()]; kwargs...)\n\nLike integral but integrates along the domain defined by ring. The specified integration rule is applied independently to each segment formed by consecutive points in the Ring.\n\n\n\n\n\n","category":"method"},{"location":"api/#MeshIntegrals.integral-Union{Tuple{I}, Tuple{Any, Meshes.Rope, I}} where I<:IntegrationRule","page":"Public API","title":"MeshIntegrals.integral","text":"integral(f, rope::Rope[, rule = GaussKronrod()]; kwargs...)\n\nLike integral but integrates along the domain defined by rope. The specified integration rule is applied independently to each segment formed by consecutive points in the Rope.\n\n\n\n\n\n","category":"method"},{"location":"api/#MeshIntegrals._ParametricGeometry","page":"Public API","title":"MeshIntegrals._ParametricGeometry","text":"_ParametricGeometry <: Meshes.Primitive <: Meshes.Geometry\n\n_ParametricGeometry is used internally in MeshIntegrals.jl to behave like a generic wrapper for geometries with custom parametric functions. This type is used for transforming other geometries to enable integration over the standard rectangular [0,1]^n domain.\n\nMeshes.jl adopted a ParametrizedCurve type that performs a similar role as of v0.51.20, but only supports geometries with one parametric dimension. Support is additionally planned for more types that span surfaces and volumes, at which time this custom type will probably no longer be required.\n\nFields\n\nfun - anything callable representing a parametric function: (ts...) -> Meshes.Point\n\nType Structure\n\nM <: Meshes.Manifold - same usage as in Meshes.Geometry{M, C}\nC <: CoordRefSystems.CRS - same usage as in Meshes.Geometry{M, C}\nF - type of the callable parametric function\nDim - number of parametric dimensions\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals._ParametricGeometry-Tuple{Any, Int64}","page":"Public API","title":"MeshIntegrals._ParametricGeometry","text":"_ParametricGeometry(fun, dims)\n\nConstruct a _ParametricGeometry using a provided parametric function fun for a geometry with dims parametric dimensions.\n\nArguments\n\nfun - anything callable representing a parametric function mapping (ts...) -> Meshes.Point\ndims::Int64 - number of parametric dimensions, i.e. length(ts)\n\n\n\n\n\n","category":"method"},{"location":"api/#MeshIntegrals._parametric","page":"Public API","title":"MeshIntegrals._parametric","text":"_parametric(geometry::G) where {G <: Meshes.Geometry} -> Function\n\nUsed in MeshIntegrals.jl for defining parametric functions that transform non-standard geometries into a form that can be integrated over the standard rectangular [0,1]^n limits.\n\n\n\n\n\n","category":"function"},{"location":"api/#MeshIntegrals.lineintegral","page":"Public API","title":"MeshIntegrals.lineintegral","text":"lineintegral(f, geometry[, rule]; FP=Float64)\n\nNumerically integrate a given function f(::Point) along a line-like geometry using a particular numerical integration rule with floating point precision of type FP.\n\nThis is a convenience wrapper around integral that additionally enforces a requirement that the geometry have one parametric dimension.\n\nRule types available:\n\nGaussKronrod (default)\nGaussLegendre\nHAdaptiveCubature\n\n\n\n\n\n","category":"function"},{"location":"api/#MeshIntegrals.surfaceintegral","page":"Public API","title":"MeshIntegrals.surfaceintegral","text":"surfaceintegral(f, geometry[, rule]; FP=Float64)\n\nNumerically integrate a given function f(::Point) along a surface geometry using a particular numerical integration rule with floating point precision of type FP.\n\nThis is a convenience wrapper around integral that additionally enforces a requirement that the geometry have two parametric dimensions.\n\nAlgorithm types available:\n\nGaussKronrod\nGaussLegendre\nHAdaptiveCubature (default)\n\n\n\n\n\n","category":"function"},{"location":"api/#MeshIntegrals.volumeintegral","page":"Public API","title":"MeshIntegrals.volumeintegral","text":"volumeintegral(f, geometry[, rule]; FP=Float64)\n\nNumerically integrate a given function f(::Point) throughout a volumetric geometry using a particular numerical integration rule with floating point precision of type FP.\n\nThis is a convenience wrapper around integral that additionally enforces a requirement that the geometry have three parametric dimensions.\n\nAlgorithm types available:\n\nGaussKronrod\nGaussLegendre\nHAdaptiveCubature (default)\n\n\n\n\n\n","category":"function"},{"location":"api/#MeshIntegrals.GaussKronrod","page":"Public API","title":"MeshIntegrals.GaussKronrod","text":"GaussKronrod(kwargs...)\n\nThe h-adaptive Gauss-Kronrod quadrature rule implemented by QuadGK.jl which can be used for any single-dimensional geometry. All standard QuadGK.quadgk keyword arguments are supported.\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals.GaussLegendre","page":"Public API","title":"MeshIntegrals.GaussLegendre","text":"GaussLegendre(n)\n\nAn n'th-order Gauss-Legendre quadrature rule. Nodes and weights are efficiently calculated using FastGaussQuadrature.jl.\n\nSo long as the integrand function can be well-approximated by a polynomial of order 2n-1, this method should yield results with 16-digit accuracy in O(n) time. If the function is know to have some periodic content, then n should (at a minimum) be greater than the expected number of periods over the geometry, e.g. length(geometry)/Î».\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals.HAdaptiveCubature","page":"Public API","title":"MeshIntegrals.HAdaptiveCubature","text":"HAdaptiveCubature(kwargs...)\n\nThe h-adaptive cubature rule implemented by HCubature.jl. All standard HCubature.hcubature keyword arguments are supported.\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals.AutoEnzyme","page":"Public API","title":"MeshIntegrals.AutoEnzyme","text":"AutoEnzyme()\n\nUse to specify use of the Enzyme.jl for calculating derivatives.\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals.DifferentiationMethod","page":"Public API","title":"MeshIntegrals.DifferentiationMethod","text":"DifferentiationMethod\n\nA category of types used to specify the desired method for calculating derivatives. Derivatives are used to form Jacobian matrices when calculating the differential element size throughout the integration region.\n\nSee also FiniteDifference, AutoEnzyme.\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals.FiniteDifference","page":"Public API","title":"MeshIntegrals.FiniteDifference","text":"FiniteDifference(Îµ=1e-6)\n\nUse to specify use of a finite-difference approximation method with a step size of Îµ for calculating derivatives.\n\n\n\n\n\n","category":"type"},{"location":"api/#MeshIntegrals.differential-Union{Tuple{T}, Tuple{G}, Tuple{G, Union{Tuple{T, Vararg{T}}, AbstractVector{T}}}, Tuple{G, Union{Tuple{T, Vararg{T}}, AbstractVector{T}}, DifferentiationMethod}} where {G<:Meshes.Geometry, T<:AbstractFloat}","page":"Public API","title":"MeshIntegrals.differential","text":"differential(geometry, ts[, diff_method])\n\nCalculate the differential element (length, area, volume, etc) of the parametric function for geometry at arguments ts. Optionally, direct the use of a particular differentiation method diff_method; by default use analytic solutions where possible and finite difference approximations otherwise.\n\nArguments\n\ngeometry: some Meshes.Geometry of N parametric dimensions\nts: a parametric point specified as a vector or tuple of length N\ndiff_method: the desired DifferentiationMethod to use\n\n\n\n\n\n","category":"method"},{"location":"api/#MeshIntegrals.jacobian-Union{Tuple{T}, Tuple{G}, Tuple{G, Union{Tuple{T, Vararg{T}}, AbstractVector{T}}}} where {G<:Meshes.Geometry, T<:AbstractFloat}","page":"Public API","title":"MeshIntegrals.jacobian","text":"jacobian(geometry, ts[, diff_method])\n\nCalculate the Jacobian of a geometry's parametric function at some point ts. Optionally, direct the use of a particular differentiation method diff_method; by default use analytic solutions where possible and finite difference approximations otherwise.\n\nArguments\n\ngeometry: some Meshes.Geometry of N parametric dimensions\nts: a parametric point specified as a vector or tuple of length N\ndiff_method: the desired DifferentiationMethod to use\n\n\n\n\n\n","category":"method"},{"location":"integration_rules/#Integration-Rules","page":"Integration Rules","title":"Integration Rules","text":"An integration rule is a method or algorithm used to numerically calculate the value of an integral. When an integral is calculated using the two-argument form integral(f, geometry), MeshIntegrals.jl will automatically select an integration rule. Default rules are generally well-behaved, but may not be optimal for every problem.\n\nMeshIntegrals.jl defines an abstract type IntegrationRule with sub-types representing the various integration rules supported by this package. These rules can be specified when calculating an integral using the three-argument form integral(f, geometry, rule). Currently, the following rule types are implemented:\n\nGaussKronrod for adaptive Gauss-Kronrod quadrature rules\nGaussLegendre for Gauss-Legendre quadrature rules\nHAdaptiveCubature for h-adaptive cubature rules","category":"section"},{"location":"integration_rules/#gausskronrod","page":"Integration Rules","title":"Gauss-Kronrod","text":"The GaussKronrod type is used to specify an adaptive Gauss-Kronrod quadrature rule, as implemented by QuadGK.jl.\n\nrule = GaussKronrod()\n\nAll standard QuadGK.quadgk keyword-argument options are supported. These can be specified when constructing the rule, where the kwargs in GaussKronrod(kwargs...) is equivalent to quadgk(f, a, b; kwargs...), e.g.:\n\nrule = GaussKronrod(order = 5, rtol = 1e-4)","category":"section"},{"location":"integration_rules/#gausslegendre","page":"Integration Rules","title":"Gauss-Legendre","text":"The GaussLegendre type is used to specify a Gauss-Legendre quadrature rule. Gauss-Legendre quadrature rules of order N are used to approximate definite integrals by sampling the integrand on a fixed grid with corresponding nodes x_i and weights w_i.\n\nint_-1^1 f(x) textdx approx sum_i=1^N w_i  f(x_i)\n\nThese nodes and weights are purely a function of N as they are derived from the roots of N-th order Legendre polynomials. This has the effect of providing exact solutions for integrand functions f that can be represented as degree 2N-1 polynomials.\n\nThis integration process can also be extended into multiple dimensions, for example:\n\nint_-1^1 int_-1^1 int_-1^1 f(x y z) textdx textdy textdz approx sum_i=1^N sum_j=1^N sum_k=1^N w_iw_jw_k  f(x_i y_i z_i)\n\nMeshIntegrals.jl uses FastGaussQuadrature.jl to efficiently compute Gauss-Legendre quadrature nodes and weights at the time a GaussLegendre rule is constructed. Once constructed, these rules can be re-used to calculate multiple integrals to improve performance. Additionally, MeshIntegrals.jl uses an allocation-free summation routine that further improves performance by avoiding storing intermediate results.\n\nrule = GaussLegendre(N)\n\nBy contrast to adaptive integration rules where compute times can sometimes vary significantly, this technique has the advantage that compute times are much more predictable. For example, calculating a one-dimensional integral whose integrand f can be computed in 10 microseconds using a GaussLegendre(100) can be expected to take approximately 1 millisecond. However, this lacks many of the guard-rails present in adaptive routines: results are not automatically checked to ensure convergence, so care must be taken to ensure that an appropriate rule and order are chosen.","category":"section"},{"location":"integration_rules/#hadaptivecubature","page":"Integration Rules","title":"H-Adaptive Cubature","text":"The HAdaptiveCubature type is used to specify an h-adaptive cubature rule, as implemented by HCubature.jl.\n\nrule = HAdaptiveCubature()\n\nAll standard HCubature.hcubature keyword-argument options are supported. These can be specified when constructing the rule, where the kwargs in HAdaptiveCubature(kwargs...) is equivalent to hcubature(f, a, b; kwargs...), e.g.:\n\nrule = HAdaptiveCubature(order = 5, rtol = 1e-4)","category":"section"},{"location":"developer/CHANGELOG/#Changelog","page":"Changelog","title":"Changelog","text":"All notable changes to this project will be documented in this file.\n\nThe format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"section"},{"location":"developer/CHANGELOG/#[Unreleased]","page":"Changelog","title":"[Unreleased]","text":"","category":"section"},{"location":"developer/CHANGELOG/#[0.17.2]-2025-12-11","page":"Changelog","title":"[0.17.2] - 2025-12-11","text":"Updated compatibility entry for Meshes.jl to support v0.56 (#214).","category":"section"},{"location":"developer/CHANGELOG/#[0.17.1]-2025-10-09","page":"Changelog","title":"[0.17.1] - 2025-10-09","text":"Updated compatibility entry for CoordRefSystems.jl to support v0.19 and for Meshes.jl to support v0.55 (#205).","category":"section"},{"location":"developer/CHANGELOG/#[0.17.0]-2025-08-18","page":"Changelog","title":"[0.17.0] - 2025-08-18","text":"","category":"section"},{"location":"developer/CHANGELOG/#Changed","page":"Changelog","title":"Changed","text":"Increased minimum dependency version for Meshes.jl to v0.53 and CoordRefSystems.jl to 0.16 to support some new geometry types and make use of new helper functions.","category":"section"},{"location":"developer/CHANGELOG/#Removed","page":"Changelog","title":"Removed","text":"Removed previously-deprecated support for use of GaussKronrod rules on geometries with more than one parametric dimension.","category":"section"},{"location":"developer/CHANGELOG/#[0.16.4]-2025-08-10","page":"Changelog","title":"[0.16.4] - 2025-08-10","text":"","category":"section"},{"location":"developer/CHANGELOG/#Added","page":"Changelog","title":"Added","text":"Adds integral methods for PolyArea and subtypes of Domain with explicit tests for CartesianGrid, PolyArea, RegularGrid, SimpleMesh, and StructuredGrid.\nAdds Base.show methods for nicer display of integration rule types.","category":"section"},{"location":"developer/CHANGELOG/#Changed-2","page":"Changelog","title":"Changed","text":"Generalizes the alias functions (e.g. lineintegral) to also accept Domains.\nUpdated docstrings to improve clarity and consistency.","category":"section"},{"location":"developer/CHANGELOG/#[0.16.3]-2025-06-26","page":"Changelog","title":"[0.16.3] - 2025-06-26","text":"","category":"section"},{"location":"developer/CHANGELOG/#Changed-3","page":"Changelog","title":"Changed","text":"Updated compatibility entry for CoordRefSystems.jl to support v0.17 and v0.18 (#175, #180).","category":"section"},{"location":"developer/CHANGELOG/#[0.16.2]-2025-03-16","page":"Changelog","title":"[0.16.2] - 2025-03-16","text":"","category":"section"},{"location":"developer/CHANGELOG/#Added-2","page":"Changelog","title":"Added","text":"Add official support for integrating over Frustum, Pyramid, and Wedge geometries (#168).","category":"section"},{"location":"developer/CHANGELOG/#Changed-4","page":"Changelog","title":"Changed","text":"Improved unit testing with analytical solutions (#162, #166).\nMade significant improvements to documentation (#165).\nUpdated compatibility entry for Meshes.jl to support v0.53 (#170, #171).\nUpdates several CI dependencies (#163, #167, #172).","category":"section"},{"location":"developer/CHANGELOG/#[0.16.1]-2024-12-29","page":"Changelog","title":"[0.16.1] - 2024-12-29","text":"","category":"section"},{"location":"developer/CHANGELOG/#Changed-5","page":"Changelog","title":"Changed","text":"Implemented a more efficient internal parametric transformation for Meshes.Tetrahedron, resulting in about an 80% integral performance improvement.","category":"section"},{"location":"developer/CHANGELOG/#Fixed","page":"Changelog","title":"Fixed","text":"Fixed a bug where integral would default to diff_method=AutoEnzyme() even when the Enzyme extension isn't loaded.","category":"section"},{"location":"developer/CHANGELOG/#[0.16.0]-2024-12-14","page":"Changelog","title":"[0.16.0] - 2024-12-14","text":"","category":"section"},{"location":"developer/CHANGELOG/#Added-3","page":"Changelog","title":"Added","text":"Added a diff_method keyword argument to the integral API, allowing the user to specify which differentiation method should be used when calculating differential element magnitudes throughout the integration domain.\nImplemented DifferentiationMethod types:\nFiniteDifference for finite-difference approximation.\nAutoEnzyme for using Enzyme.jl automatic differentiation (AD) via a package extension.\nAdded diff_method as an optional third argument to the jacobian and differential API.\nAdds standardized support for integrating over Tetrahedron volumes.\nGeneralizes integrand functions to support any f::Any with a method defined for f(::Point).\nRefactored specialization methods by implementing an internal _ParametricGeometry <: Meshes.Geometry to define geometries with custom parametric functions, standardizing support for BezierCurve, Line, Plane, Ray, Tetrahedron, and Triangle.\nSignificant performance improvements:\nAchieved an 80x improvement when integrating over BezierCurve.\nAchieved an up-to-4x improvement when integrating using HAdaptiveCubature.","category":"section"},{"location":"developer/CHANGELOG/#Deprecated","page":"Changelog","title":"Deprecated","text":"Deprecated manual specification of GaussKronrod rules for surfaces, i.e. geometries where Meshes.paramdim(geometry) == 2. A warning is now generated recommending users switch to HAdaptiveCubature.","category":"section"},{"location":"developer/CHANGELOG/#Fixed-2","page":"Changelog","title":"Fixed","text":"Refactored the unit test system.\nStandardized combinations.jl tests by constructing a TestableGeometry package and passing it to a @test generation function to provide more thorough and standardized test coverage.\nReorganized @testsnippets to exist in same source file as relevant tests.\nRemoved :extended tag from Tetrahedron now that performance is significantly improved.","category":"section"},{"location":"developer/CHANGELOG/#[0.15.2]-2024-10-25","page":"Changelog","title":"[0.15.2] - 2024-10-25","text":"MeshIntegrals.jl is now owned by the JuliaGeometry organization!","category":"section"},{"location":"developer/CHANGELOG/#Added-4","page":"Changelog","title":"Added","text":"Added a benchmarking suite using AirspeedVelocity.jl.\nImplemented more unit tests with analytical solutions.","category":"section"},{"location":"developer/CHANGELOG/#Changed-6","page":"Changelog","title":"Changed","text":"Tagged unit tests for Meshes.Box (4D) and Tetrahedron as :extended, removing them from automatic CI testing due to lengthy compute times.","category":"section"},{"location":"developer/CHANGELOG/#[0.15.1]-2024-10-11","page":"Changelog","title":"[0.15.1] - 2024-10-11","text":"","category":"section"},{"location":"developer/CHANGELOG/#Added-5","page":"Changelog","title":"Added","text":"Adds official support and unit testing for integrating new Meshes.ParametrizedCurve geometries.","category":"section"},{"location":"developer/CHANGELOG/#[0.15.0]-2024-10-10","page":"Changelog","title":"[0.15.0] - 2024-10-10","text":"","category":"section"},{"location":"developer/CHANGELOG/#Added-6","page":"Changelog","title":"Added","text":"Adds support for integrating geometries with any number of parametric dimensions by generalizing differential to n-dimensions via geometric algebra.\nAdds official support and unit testing for integrating Meshes.Ellipsoid and Meshes.Hexahedron geometries.","category":"section"},{"location":"developer/CHANGELOG/#Changed-7","page":"Changelog","title":"Changed","text":"Refactored the unit test system.\nCompleted transition away from previous @test generation system which only tested unit integrands (i.e. f(point) = 1.0) using Meshes.measure as a benchmark.\nUsed TestItems.jl to define independent @testitem packages, many with analytically-derived solutions.","category":"section"},{"location":"developer/CHANGELOG/#[0.14.1]-2024-10-04","page":"Changelog","title":"[0.14.1] - 2024-10-04","text":"","category":"section"},{"location":"developer/CHANGELOG/#Added-7","page":"Changelog","title":"Added","text":"Adds official support and unit testing for integrating Meshes.Quadrangle geometries.","category":"section"},{"location":"developer/CHANGELOG/#Changed-8","page":"Changelog","title":"Changed","text":"Continued work transitioning away from previous @test generation system.","category":"section"},{"location":"developer/CHANGELOG/#Fixed-3","page":"Changelog","title":"Fixed","text":"Fixed a bug in differential finite-difference approximation that may have reduced accuracy of some integral calculations.\nMade improvements to type stability with floating point type keyword argument FP.","category":"section"},{"location":"developer/CHANGELOG/#[0.14.0]-2024-09-28","page":"Changelog","title":"[0.14.0] - 2024-09-28","text":"","category":"section"},{"location":"developer/CHANGELOG/#Changed-9","page":"Changelog","title":"Changed","text":"Rename IntegrationAlgorithm to IntegrationRule and consolidate terminology around integration rules (versus \"algorithms\", \"settings\", etc).\nConvert floating point precision option FP from an optional argument to a keyword argument.\nContinued work transitioning away from previous @test generation system.","category":"section"},{"location":"developer/CHANGELOG/#Removed-2","page":"Changelog","title":"Removed","text":"Remove derivative and unitdirection functions. All derivative functionality was merged into jacobian.","category":"section"},{"location":"support/#Support-Status","page":"Support Status","title":"Support Status","text":"This library aims to enable users to calculate the value of integrals over all Meshes.jl geometry types using a number of numerical integration rules and techniques.\n\nIn general, GaussKronrod integration rules are recommended (and the default) for geometries with one parametric dimension. For geometries with more than one parametric dimension, e.g. surfaces and volumes, HAdaptiveCubature rules are recommended (and the default).","category":"section"},{"location":"support/#The-Support-Matrix","page":"Support Status","title":"The Support Matrix","text":"The following Support Matrix captures the current state of support for all geometry/rule combinations. Entries with a green check mark are fully supported and pass unit tests designed to check for accuracy.\n\nMeshes.Geometry/Domain GaussKronrod GaussLegendre HAdaptiveCubature\nBall in ð”¼{2} ðŸ›‘ âœ… âœ…\nBall in ð”¼{3} ðŸ›‘ âœ… âœ…\nBezierCurve âœ… âœ… âœ…\nBox in ð”¼{1} âœ… âœ… âœ…\nBox in ð”¼{2} ðŸ›‘ âœ… âœ…\nBox in ð”¼{â‰¥3} ðŸ›‘ âœ… âœ…\nCartesianGrid in ð”¼{1} âœ… âœ… âœ…\nCartesianGrid in ð”¼{â‰¥2} ðŸ›‘ âœ… âœ…\nCircle âœ… âœ… âœ…\nCone ðŸ›‘ âœ… âœ…\nConeSurface ðŸ›‘ âœ… âœ…\nCylinder ðŸ›‘ âœ… âœ…\nCylinderSurface ðŸ›‘ âœ… âœ…\nDisk ðŸ›‘ âœ… âœ…\nEllipsoid ðŸ›‘ âœ… âœ…\nFrustum ðŸ›‘ âœ… âœ…\nFrustumSurface ðŸ›‘ âœ… âœ…\nHexahedron ðŸ›‘ âœ… âœ…\nLine âœ… âœ… âœ…\nParaboloidSurface ðŸ›‘ âœ… âœ…\nParametrizedCurve âœ… âœ… âœ…\nPlane ðŸ›‘ âœ… âœ…\nPolyArea ðŸ›‘ âœ… âœ…\nPyramid ðŸ›‘ âœ… âœ…\nQuadrangle ðŸ›‘ âœ… âœ…\nRay âœ… âœ… âœ…\nRegularGrid in ð”¼{1} âœ… âœ… âœ…\nRegularGrid in ð”¼{â‰¥2} ðŸ›‘ âœ… âœ…\nRing âœ… âœ… âœ…\nRope âœ… âœ… âœ…\nSegment âœ… âœ… âœ…\nSimpleMesh ðŸ›‘ âœ… âœ…\nSphere ðŸ›‘ âœ… âœ…\nStructuredGrid in ð”¼{1} âœ… âœ… âœ…\nStructuredGrid in ð”¼{â‰¥2} ðŸ›‘ âœ… âœ…\nTetrahedron ðŸ›‘ âœ… âœ…\nTriangle ðŸ›‘ âœ… âœ…\nTorus ðŸ›‘ âœ… âœ…\nWedge ðŸ›‘ âœ… âœ…\n\nSymbol Support Level\nâœ… Supported\nðŸ›‘ Not supported","category":"section"},{"location":"developer/how_it_works/#howitworks","page":"How it Works","title":"How it Works","text":"","category":"section"},{"location":"developer/how_it_works/#Example-Problem","page":"How it Works","title":"Example Problem","text":"Let f be a function of position barr in some space.\n\nfunction f(rÌ„::Meshes.Point)\n    x, y, z = to(rÌ„)\n    ...\nend\n\nLet the integration domain be the space (a ball) enclosed by a sphere centered on the origin with a radius of 5 meters.\n\ncenter = Meshes.Point(0u\"m\", 0u\"m\", 0u\"m\")\nradius = 5.0u\"m\"\nball = Meshes.Ball(center, radius)\n\nThis integral is often expressed abstractly as simply the following, where the triple integral signs and textdV indicate that the integration domain is some three-dimensional volume.\n\niiint f(barr)  textdV\n\nIntegrals like this are often solved manually by selecting an appropriate coordinate system and limits that neatly represent the integration domain, e.g.\n\nint_0^pi int_0^2pi int_0^5 f(barr)  textdrhotextdthetatextdphi\n\nThis works great for simple geometries, but requires integration code that is geometry-specific. This package leverages parametric functions defined in Meshes.jl and differential forms to define integral methods that are general solutions for all geometries.","category":"section"},{"location":"developer/how_it_works/#how-parametric","page":"How it Works","title":"Parametric Functions","text":"Every supported Meshes.Geometry type is defined as having a parametric function that maps from a local parametric coordinate system to every point on the geometry. Curve-like geometries will have a single parametric dimension, surfaces will have two dimensions, and volumes will have three dimensions; this can be checked for a particular geometry via Meshes.paramdim(geometry).\n\nFor consistency across geometry types, with some notable exceptions, these parametric functions are defined to take coordinates inside a normalized range 01. In the example case of ball, Meshes.jl defines a parametric function mapped in normalized spherical coordinates (t_rho t_theta t_phi). We find, then:\n\nMeshes.paramdim(ball) == 3    # a volume\n\nball(tÏ, tÎ¸, tÏ†)    # for args in range [0, 1], maps to a corresponding Meshes.Point\n\nball(0, tÎ¸, tÏ†) == center\n\nIn effect, we can now use the geometry itself as a function that maps from three normalized (0 le t le 1) arguments to every point on the geometry. For the sake of generalization, let this parametric function be called g.\n\ntextg (t_1t_2t_3) mapsto textPointbig x y z big  ","category":"section"},{"location":"developer/how_it_works/#Differential-Forms","page":"How it Works","title":"Differential Forms","text":"Using differential forms, the general solution for integrating a geometry with three parametric dimensions (t_1, t_2, and t_3) is\n\niiint f(r)  textdV = iiint f(barr)  bartextdt_1 wedge bartextdt_2 wedge bartextdt_3\n\nThis resultant differential (volume) element is formed at each point in the integration domain by taking the Jacobian of the parametric function.\n\nmathbfJ_f = beginbmatrix bartextdt_1  bartextdt_2  bartextdt_3 endbmatrix\n\nwhere\n\nbartextdt_n = fracpartialpartial t_n  textg(t_1t_2t_3)\n\nEach of these partial derivatives is a vector representing the direction that changing each parametric function argument will move the resultant point. The differential element (E) size is then calculated using geometric algebra as the magnitude of the exterior product (wedge) of these three vectors.\n\nE(t_1t_2t_3) = left bartextdt_1 wedge bartextdt_2 wedge bartextdt_3 right\n\nFinally, we use the parametric function itself, g, as a map to all points barr in the integration domain. Since Meshes.Geometry parametric functions all operate on normalized domains, we can now solve any volume integral as simply\n\nint_0^1 int_0^1 int_0^1 fBig(textgbig(t_1t_2t_3big)Big)  E(t_1t_2t_3)  textdt_1  textdt_2  textdt_3\n\nThis form of integral can be trivially generalized to support n-dimensional geometries in a form that enables the use of a wide range of numerical integration libraries.","category":"section"},{"location":"developer/specializations/#specializations","page":"Specializations","title":"Specializations","text":"There are several notable exceptions to how Meshes.jl defines parametric functions.\n\nMeshes.ConeSurface is essentially a composite type and has a parametric function that only maps the conical portion of the geometry, so the Meshes.Disk base element has to be integrated separately.\nMeshes.CylinderSurface is essentially a composite type and has a parametric function that only maps the cylindrical portion of the geometry, so the Meshes.Disk element has to be integrated separately.\nMeshes.FrustumSurface is essentially a composite type and has a parametric function that only maps the cylindrical portion of the geometry, so the top and bottom Meshes.Disk elements have to be integrated separately.\nMeshes.Line represents a line of infinite length that passes through two points, and it has a parametric function that is valid on the domain (-infty infty).\nMeshes.Plane represents a plane of infinite extent, and it has a parametric function that is valid on the domain (-infty infty)^2.\nMeshes.Ray represents a line that begins at a point and extends in a particular direction with infinite length, and it has a parametric function that is valid on the domain 0 infty).\nMeshes.Ring is a composite type that lacks a parametric function, but can be decomposed into Meshes.Segments and then integrated by adding together the individual integrals.\nMeshes.Rope is a composite type that lacks a parametric function, but can be decomposed into Meshes.Segments and then integrated by adding together the individual integrals.\nMeshes.Triangle has a parametric function that takes coordinates on a 2D barycentric coordinate system. So, for (::Meshes.Triangle)(t1, t2), the coordinates must obey: t_1 t_2 in 01 where t_1 + t_2 le 1.\nMeshes.Tetrahedron has a parametric function that takes coordinates on a 3D barycentric coordinate system. So, for (::Meshes.Tetrahedron)(t1, t2), the coordinates must obey: t_1 t_2 t_3 in 01 where t_1 + t_2 + t_3 le 1.","category":"section"},{"location":"#MeshIntegrals.jl","page":"About","title":"MeshIntegrals.jl","text":"(Image: Docs-stable) (Image: Docs-dev) (Image: License: MIT) (Image: ColPrac)\n\n(Image: Build Status) (Image: codecov) (Image: Coveralls) (Image: Aqua QA)\n\nMeshIntegrals.jl uses differential forms to enable fast and easy numerical integration of arbitrary integrand functions over domains defined via Meshes.jl geometries. This is achieved using:\n\nGauss-Legendre quadrature rules from FastGaussQuadrature.jl: GaussLegendre(n)\nH-adaptive Gauss-Kronrod quadrature rules from QuadGK.jl: GaussKronrod(kwargs...)\nH-adaptive cubature rules from HCubature.jl: HAdaptiveCubature(kwargs...)\n\nThese solvers have support for integrand functions that produce scalars, vectors, and Unitful.jl Quantity types. While HCubature.jl does not natively support Quantity type integrands, this package provides a compatibility layer to enable this feature.","category":"section"},{"location":"#Usage","page":"About","title":"Usage","text":"","category":"section"},{"location":"#Basic","page":"About","title":"Basic","text":"integral(f, geometry)\n\nPerforms a numerical integration of some integrand function f over the domain specified by geometry. The integrand function can be anything callable with a method f(::Meshes.Point). A default integration method will be automatically selected according to the geometry: GaussKronrod() for 1D, and HAdaptiveCubature() for all others.\n\nintegral(f, geometry, rule)\n\nPerforms a numerical integration of some integrand function f over the domain specified by geometry using the specified integration rule, e.g. GaussKronrod(). The integrand function can be anything callable with a method f(::Meshes.Point).\n\nAdditionally, several optional keyword arguments are defined in the API to provide additional control over the integration mechanics.","category":"section"},{"location":"#Aliases","page":"About","title":"Aliases","text":"lineintegral(f, geometry)\nsurfaceintegral(f, geometry)\nvolumeintegral(f, geometry)\n\nAlias functions are provided for convenience. These are simply wrappers for integral that also validate that the provided geometry has the expected number of parametric dimensions. Like with integral, a rule can also optionally be specified as a third argument.\n\nlineintegral is used for curve-like geometries or polytopes (e.g. Segment, Ray, BezierCurve, Rope, etc)\nsurfaceintegral is used for surfaces (e.g. Disk, Sphere, CylinderSurface, etc)\nvolumeintegral is used for (3D) volumes (e.g. Ball, Cone, Torus, etc)","category":"section"},{"location":"#Example","page":"About","title":"Example","text":"using Meshes\nusing MeshIntegrals\nusing Unitful\n\n# Define a Bezier curve whose path approximates a sine-wave on the xy-plane\nN = 361\ncurve = BezierCurve([Point(t*u\"m\", sin(t)*u\"m\", 0.0u\"m\") for t in range(-Ï€, Ï€, length=N)])\n\n# Integrand function that outputs in units of Ohms/meter\nfunction f(p::Point)\n    x, y, z = to(p)\n    return (1 / sqrt(1 + cos(x / u\"m\")^2)) * u\"Î©/m\"\nend\n\n# Use recommended defaults\nintegral(f, curve) # -> Approximately 2Ï€ Î©\n\n# Using aliases\nlineintegral(f, curve) # -> Approximately 2Ï€ Î©\nsurfaceintegral(f, curve) # -> throws ArgumentError\n\n# Specifying an integration rule and settings (loosened absolute tolerance)\nintegral(f, curve, GaussKronrod(atol = 1e-4u\"Î©\")) # -> Approximately (2Ï€ Â± 1e-4) Î©","category":"section"},{"location":"tips/#Tips","page":"Tips","title":"Tips","text":"","category":"section"},{"location":"tips/#General-Usage","page":"Tips","title":"General Usage","text":"","category":"section"},{"location":"tips/#Make-use-of-the-Enzyme-extension","page":"Tips","title":"Make use of the Enzyme extension","text":"note: Note\nSee How it Works for a more thorough explanation of how MeshIntegrals.jl uses differential forms to solve integral problems.\n\nMeshIntegrals.jl uses differential forms to solve integral problems. At every sampled point in the geometry that forms the integration domain a differential element magnitude must be calculated, which involves calculating the jacobian of the geometry's parametric function. MeshIntegrals.jl includes multiple method options for calculating this jacobian which are selectable via integrals keyword argument diff_method.\n\nThe default/fallback jacobian method uses a finite-difference approximation method, which is reasonably performant and compatible with all geometry types. However, this method can potentially introduce a small amount of approximation error into solutions. This method can be explicitly selected via the keyword argument:\n\nintegral(f, geometry; diff_method = FiniteDifference())\n\nMeshIntegrals.jl includes an extension for Enzyme.jl, using it to implement an automatic differentiation-based jacobian method. This method is typically faster and more accurate, but it is not currently compatible with all geometries. This extension will automatically be loaded when Enzyme.jl is present in the active Julia environment. When loaded, this method will automatically be used by integral whenever it is compatible with the given geometry. This method can also be explicitly selected via the keyword argument:\n\nusing Enzyme\n\nintegral(f, geometry; diff_method = AutoEnzyme())","category":"section"},{"location":"tips/#Performance","page":"Tips","title":"Performance","text":"","category":"section"},{"location":"tips/#Using-explicit-tolerance-settings-with-adaptive-integration-rules","page":"Tips","title":"Using explicit tolerance settings with adaptive integration rules","text":"note: Note\nThis tip is applicable to the use of GaussKronrod and HAdaptiveCubature integration rules.\n\nThe GaussKronrod and HAdaptiveCuabture integration rules both make use of adaptive solvers that use relative tolerance (rtol) settings to determine when the result is sufficiently precise to return a solution. Under some circumstances these solvers may struggle to converge on a precise enough solution, resulting in extended compute times. This commonly occurs for integrand functions that are numerically unstable or whose solution is zero or near-zero. In such a case, performance can often be improved by explicitly providing an absolute tolerance setting (atol).\n\nThis can be observed by benchmarking the integration of an integral problem whose true solution is exactly zero.\n\nint_-1textm^1textm x lefttfractextNtextmright  textdx\n= 0 textNm\n\nusing BenchmarkTools, Meshes, MeshIntegrals, Unitful\nsegment = Segment(Point(-1u\"m\"), Point(1u\"m\"))\nf(p::Meshes.Point) = p.coords.x * u\"N/m\"\n\nCalculating this problem with a default GaussKronrod() rule produces a solution that is very close to zero, on the order of 10^-11. However, the result took a non-trivial amount of time due to a large number of memory allocatons for such a trivial problem.\n\n@btime integral(f, segment, GaussKronrod())\n\nProviding an explicit atol setting produces a solution that happens to be just as accurate but returns much faster.\n\n@btime integral(f, segment, GaussKronrod(atol = 1e-8u\"N*m\"))","category":"section"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Installation","page":"Tutorial","title":"Installation","text":"MeshIntegrals.jl is registered in the official Julia General registry, enabling it to be easily installed using Julia on an internet-connected computer. MeshIntegrals.jl should usually be installed in conjunction with Meshes.jl and Unitful.jl which provide support for geometries and physical units, respectively.\n\nMeshIntegrals.jl can be installed from the Julia REPL by entering pkg mode with the ] key and adding it by name\n\npkg> add MeshIntegrals\n\nor by calling the built-in Pkg.jl library.\n\nimport Pkg\nPkg.add(\"MeshIntegrals\")","category":"section"},{"location":"tutorial/#Basic-Usage","page":"Tutorial","title":"Basic Usage","text":"Usage of MeshIntegrals.jl typically also involves using Meshes.jl and Unitful.jl, so all three packages will be used in this example.\n\nusing Meshes\nusing MeshIntegrals\nusing Unitful","category":"section"},{"location":"tutorial/#Define-a-Geometry-to-Use-as-an-Integration-Domain","page":"Tutorial","title":"Define a Geometry to Use as an Integration Domain","text":"Here, representing the domain being integrated over, we will define a Bezier curve whose path approximates a sine-wave on the xy-plane.\n\nN = 361  # number of control points\nxs = range(-Ï€, Ï€, length=N)  # x will be bounded in [-Ï€, Ï€] meters\ncurve = Meshes.BezierCurve([Point(x * u\"m\", sin(x) * u\"m\", 0.0u\"m\") for x in xs])","category":"section"},{"location":"tutorial/#Define-an-Integrand-Function","page":"Tutorial","title":"Define an Integrand Function","text":"Here, we will define an integrand function of the following form, where all coordinates are defined in a physical space with meter units and the result is a quantity in units of Ohms per meter.\n\nf(x y z) = frac1sqrt1 + cos^2(xtextm)  Omegatextm\n\nIntegrand functions are expected to provide a method that takes a single Meshes.Point argument, so this can be written in Julia as\n\nfunction f(p::Meshes.Point)\n    x, y, z = Meshes.to(p)\n    return (1 / sqrt(1 + cos(x / u\"m\")^2)) * u\"Î©/m\"\nend\n\nAlternatively, this could be written in the user-friendly notation\n\nf(x, y, z) = (1 / sqrt(1 + cos(x / u\"m\")^2)) * u\"Î©/m\"\nf(p::Meshes.Point) = f(Meshes.to(p)...)\n\nwhere the required f(Meshes.Point) method simply maps to the method f(x, y, z).","category":"section"},{"location":"tutorial/#Integrating","page":"Tutorial","title":"Integrating","text":"This function can be integrated using recommended defaults simply by calling\n\nintegral(f, curve)  # -> Approximately 2Ï€ Î©\n\nThe alias function lineintegral works for this geometry since it has one parametric dimension. However, the aliases surfaceintegral and volumeintegral will throw an ArgumentError since the geometry is not a surface or volume.\n\nlineintegral(f, curve)\n# -> Approximately 2Ï€ Î©\n\nsurfaceintegral(f, curve)\n# -> ERROR: ArgumentError: Performing a surface integral on a geometry with 1 parametric dimensions not supported.\n\nvolumeintegral(f, curve)\n# -> ERROR: ArgumentError: Performing a volume integral on a geometry with 1 parametric dimensions not supported.\n\nAn IntegrationRule with settings can also be manually specified. The following example uses the adaptive Gauss-Kronrod method with a loosened absolute tolerance setting of 10^-4Omega, which speeds up integration by sacrificing some accuracy.\n\nintegral(f, curve, GaussKronrod(atol = 1e-4u\"Î©\")) # -> Approximately (2Ï€ Â± 1e-4) Î©\n\nThe integral function and its aliases also support Julia's do-syntax, which provides a code block to define a single-use anonymous function and then injects it as a first argument to the preceding call. This can be useful if the integrand function will not be used outside this integration call.\n\nintegral(curve) do p\n    x, y, z = Meshes.to(p)\n    (1 / sqrt(1 + cos(x / u\"m\")^2)) * u\"Î©/m\"\nend # -> Approximately 2Ï€ Î©","category":"section"}]
}
